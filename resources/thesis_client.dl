#include "/home/fbioribeiro/thesis-tool/greed/gigahorse-toolchain/clientlib/decompiler_imports.dl"
#include "/home/fbioribeiro/thesis-tool/greed/gigahorse-toolchain/clientlib/loops_semantics.dl"
#include "/home/fbioribeiro/thesis-tool/greed/gigahorse-toolchain/clientlib/guards.dl"
#include "/home/fbioribeiro/thesis-tool/greed/gigahorse-toolchain/clientlib/flows.dl"

/**
 * Abstractions for the Data flow analysis
**/

.decl CallToSignatureHex(callStmt:Statement, sigHash:symbol)
CallToSignatureHex(callStmt, sigHash) :- 
  CALLStatement(callStmt, _),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, 0, sigVar),
  Variable_Value(sigVar, sigVal),
  sigHash = substr(sigVal, 0, 10).
.output CallToSignatureHex

.decl CallToOracle(sourceStmt:Statement)
CallToOracle(sourceStmt):-
  (CallToSignatureHex(sourceStmt, "0x0902f1ac");    // getReserves()
  CallToSignatureHex(sourceStmt, "0xfc57d4df");     // getUnderlyingPrice(address)
  CallToSignatureHex(sourceStmt, "0x809a9e55");     // getExpectedRate(address,address,uint256)
  CallToSignatureHex(sourceStmt, "0x49f9b0f7")).    // calculateSaleReturn(uint256,uint256,uint32,uint256)


.decl ExternalCallIsNotOracleOrSink(callStmt:Statement, funcSign:symbol)
ExternalCallIsNotOracleOrSink(callStmt, funcSign):-
  CallToSignatureHex(callStmt, funcSign),
  // Oracles
  funcSign != "0x0902f1ac",    // getReserves()
  funcSign != "0xfc57d4df",    // getUnderlyingPrice(address)
  funcSign != "0x809a9e55",    // getExpectedRate(address,address,uint256)
  funcSign != "0x49f9b0f7",    // calculateSaleReturn(uint256,uint256,uint32,uint256)
  // Sinks
  funcSign != "0xa9059cbb",    // transfer(address,uint256)
  funcSign != "0x23b872dd".    // transferFrom(address,address,uint256)

/**
 * Data flow analysis for price manipulation vulnerabilities for the Gigahorse toolchain
**/

/**
 * Complete flow from Oracle to Sink
**/
.decl CompleteFlowOracleToSink(sourceStmt:Statement, sinkStmt:Statement, amount:Variable)
CompleteFlowOracleToSink(sourceStmt, sinkStmt, amount) :-
  CallToOracle(sourceStmt),
  ExternalCall_ActualReturn(sourceStmt, priceVar, _), // taint all variables for now (more info on actual_vars on memory_modeling_api.dl)
  DataFlows(priceVar, amount), // propagate flow
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output CompleteFlowOracleToSink

/**
 * Partial flow from Oracle to ExternalCall
**/
.decl PartialFlowOracleToExternalCall(sourceStmt:Statement, callStmt:Statement, funcSign:symbol)
PartialFlowOracleToExternalCall(sourceStmt, callStmt, funcSign) :-
  CallToOracle(sourceStmt),
  ExternalCall_ActualReturn(sourceStmt, priceVar, _),
  DataFlows(priceVar, taintedVar),
  CallToSignatureHex(callStmt, funcSign),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, _, taintedVar), // statement uses taintedVar
  ExternalCallIsNotOracleOrSink(callStmt, funcSign).
.output PartialFlowOracleToExternalCall

/**
 * Partial flow from ExternalCall to ExternalCall
**/
.decl PartialFlowExternalCallToExternalCall(firstCallStmt:Statement, firstSigHash:symbol, secondCallStmt:Statement, secondSigHash:symbol)
PartialFlowExternalCallToExternalCall(firstCallStmt, firstSigHash, secondCallStmt, secondSigHash) :-
  CallToSignatureHex(firstCallStmt, firstSigHash),
  ExternalCall_ActualReturn(firstCallStmt, possiblyTaintedVar, _),
  DataFlows(possiblyTaintedVar, taintedVar),
  CallToSignatureHex(secondCallStmt, secondSigHash),
  StatementUsesMemory_ActualMemoryArg(secondCallStmt, _, _, taintedVar).
.output PartialFlowExternalCallToExternalCall

/**
 * Partial flow from CALLDATALOAD to ExternalCall
**/
.decl PartialFlowCallDataLoadToExternalCall(sourceStmt:Statement, callStmt:Statement, funcSign:symbol)
PartialFlowCallDataLoadToExternalCall(sourceStmt, callStmt, funcSign) :-
  CALLDATALOAD(sourceStmt, _, dataInputSrcVar),
  DataFlows(dataInputSrcVar, taintedVar),
  CallToSignatureHex(callStmt, funcSign),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, _, taintedVar),
  ExternalCallIsNotOracleOrSink(callStmt, funcSign).
.output PartialFlowCallDataLoadToExternalCall

/**
 * Partial flow from CALLDATALOAD to Sink
**/
.decl PartialFlowCallDataLoadToSink(sourceStmt:Statement, sinkStmt:Statement, amount:Variable)
PartialFlowCallDataLoadToSink(sourceStmt, sinkStmt, amount) :-
  CALLDATALOAD(sourceStmt, _, dataInputSrcVar),
  DataFlows(dataInputSrcVar, amount),
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output PartialFlowCallDataLoadToSink

/**
 * Partial flow from ExternalCall to Sink
**/
.decl PartialFlowExternalCallToSink(callStmt:Statement, sigHash:symbol, sinkStmt:Statement, amount:Variable)
PartialFlowExternalCallToSink(callStmt, sigHash, sinkStmt, amount) :-
  CallToSignatureHex(callStmt, sigHash),
  ExternalCall_ActualReturn(callStmt, possiblyTaintedVar, _),
  DataFlows(possiblyTaintedVar, amount),
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output PartialFlowExternalCallToSink
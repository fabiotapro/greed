#include "decompiler_imports.dl"
#include "loops_semantics.dl"
#include "guards.dl"
#include "flows.dl"

/**
 * Abstractions for the Data flow analysis
**/

.decl CallToSignatureHex(callStmt:Statement, sigHash:symbol)
CallToSignatureHex(callStmt, sigHash) :- 
  CALLStatement(callStmt, _),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, 0, sigVar),
  Variable_Value(sigVar, sigVal),
  sigHash = substr(sigVal, 0, 10).
.output CallToSignatureHex

.decl CallToOracle(sourceStmt:Statement, oracleSigHash:symbol)

CallToOracle(sourceStmt, "0x70a08231") :-
    CallToSignatureHex(sourceStmt, "0x70a08231").     // balanceOf(address)

CallToOracle(sourceStmt, "0x095ea7b3") :-
    CallToSignatureHex(sourceStmt, "0x095ea7b3").     // approve(address,uint256)

CallToOracle(sourceStmt, "0x24b31a0c") :-
    CallToSignatureHex(sourceStmt, "0x24b31a0c").     // swap(address,int256,bool,uint160,bytes)

CallToOracle(sourceStmt, "0xdd62ed3e") :-
    CallToSignatureHex(sourceStmt, "0xdd62ed3e").     // allowance(address,address)

CallToOracle(sourceStmt, "0x18160ddd") :-
    CallToSignatureHex(sourceStmt, "0x18160ddd").     // totalSupply()

CallToOracle(sourceStmt, "0x022c0d9f") :-
    CallToSignatureHex(sourceStmt, "0x022c0d9f").     // swap(uint256,uint256,address,bytes)

CallToOracle(sourceStmt, "0x0902f1ac") :-
    CallToSignatureHex(sourceStmt, "0x0902f1ac").     // getReserves()

CallToOracle(sourceStmt, "0x1f00ca74") :-
    CallToSignatureHex(sourceStmt, "0x1f00ca74").     // getAmountsIn(uint256,address[])

// CallToOracle(sourceStmt, "0xfc57d4df") :-
//     CallToSignatureHex(sourceStmt, "0xfc57d4df").     // getUnderlyingPrice(address)

// CallToOracle(sourceStmt, "0x809a9e55") :-
//     CallToSignatureHex(sourceStmt, "0x809a9e55").     // getExpectedRate(address,address,uint256)

// CallToOracle(sourceStmt, "0x49f9b0f7") :-
//     CallToSignatureHex(sourceStmt, "0x49f9b0f7").     // calculateSaleReturn(uint256,uint256,uint32,uint256)

// Use this if we want to add more custom sinks
// .decl CallToSink(sinkStmt:Statement, sinkSigHash:symbol)

// CallToSink(sinkStmt, "0xa9059cbb") :-
//     CallToSignatureHex(sinkStmt, "0xa9059cbb").     // transfer(address,uint256)

// CallToSink(sinkStmt, "0x23b872dd") :-
//     CallToSignatureHex(sinkStmt, "0x23b872dd").     // transferFrom(address,address,uint256)

// CallToSink(sinkStmt, "0x2e1a7d4d") :-
//     CallToSignatureHex(sinkStmt, "0x2e1a7d4d").     // withdraw(uint256)

// CallToSink(sinkStmt, " 0xd6febde8") :-
//     CallToSignatureHex(sinkStmt, " 0xd6febde8").     // buy(uint256, uint256)

// CallToSink(sinkStmt, "0xd79875eb") :-
//     CallToSignatureHex(sinkStmt, "0xd79875eb").     // sell(uint256, uint256)

.decl ExternalCallIsNotOracleOrSink(callStmt:Statement, sigHash:symbol)
ExternalCallIsNotOracleOrSink(callStmt, sigHash):-
  CallToSignatureHex(callStmt, sigHash),
  // Oracles
  sigHash != "0x70a08231",    // balanceOf(address)
  //sigHash != "0x0902f1ac",    // getReserves()
  //sigHash != "0xfc57d4df",    // getUnderlyingPrice(address)
  //sigHash != "0x809a9e55",    // getExpectedRate(address,address,uint256)
  //sigHash != "0x49f9b0f7",    // calculateSaleReturn(uint256,uint256,uint32,uint256)
  // Sinks
  sigHash != "0xa9059cbb",    // transfer(address,uint256)
  sigHash != "0x23b872dd".    // transferFrom(address,address,uint256)

.decl ExternalCallIsNotSink(callStmt:Statement, sigHash:symbol)
ExternalCallIsNotSink(callStmt, sigHash):-
  CallToSignatureHex(callStmt, sigHash),
  // Sinks
  sigHash != "0xa9059cbb",    // transfer(address,uint256)
  sigHash != "0x23b872dd".    // transferFrom(address,address,uint256)


/**
 * Data flow analysis for price manipulation vulnerabilities for the Gigahorse toolchain
**/

/**
 * Complete flow from Oracle to Sink
**/
.decl CompleteFlowOracleToSink(sourceStmt:Statement, oracleSigHash:symbol, sinkStmt:Statement, amount:Variable)
CompleteFlowOracleToSink(sourceStmt, oracleSigHash, sinkStmt, amount) :-
  CallToOracle(sourceStmt, oracleSigHash),
  ExternalCall_ActualReturn(sourceStmt, priceVar, _), // taint all variables for now (more info on actual_vars on memory_modeling_api.dl)
  DataFlows(priceVar, amount), // propagate flow
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output CompleteFlowOracleToSink

/**
 * Partial flow from Oracle to ExternalCall
**/
.decl PartialFlowOracleToExternalCall(sourceStmt:Statement, oracleSigHash:symbol, callStmt:Statement, callSigHash:symbol, taintedVar:Variable)
PartialFlowOracleToExternalCall(sourceStmt, oracleSigHash, callStmt, callSigHash, taintedVar) :-
  CallToOracle(sourceStmt, oracleSigHash),
  ExternalCall_ActualReturn(sourceStmt, priceVar, _),
  DataFlows(priceVar, taintedVar),
  CallToSignatureHex(callStmt, callSigHash),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, _, taintedVar), // statement uses taintedVar
  ExternalCallIsNotOracleOrSink(callStmt, callSigHash).
.output PartialFlowOracleToExternalCall

/**
 * Partial flow from ExternalCall to ExternalCall
**/
.decl PartialFlowExternalCallToExternalCall(firstCallStmt:Statement, firstSigHash:symbol, secondCallStmt:Statement, secondSigHash:symbol, taintedVar:Variable)
PartialFlowExternalCallToExternalCall(firstCallStmt, firstSigHash, secondCallStmt, secondSigHash, taintedVar) :-
  CallToSignatureHex(firstCallStmt, firstSigHash),
  ExternalCallIsNotSink(firstCallStmt, firstSigHash),
  ExternalCall_ActualReturn(firstCallStmt, possiblyTaintedVar, _),
  DataFlows(possiblyTaintedVar, taintedVar),
  CallToSignatureHex(secondCallStmt, secondSigHash),
  StatementUsesMemory_ActualMemoryArg(secondCallStmt, _, _, taintedVar),
  ExternalCallIsNotOracleOrSink(secondCallStmt, secondSigHash).
.output PartialFlowExternalCallToExternalCall

/**
 * Partial flow from CALLDATALOAD to ExternalCall
**/
.decl PartialFlowCallDataLoadToExternalCall(sourceStmt:Statement, dataInputSrcVar:Variable, callStmt:Statement, sigHash:symbol, taintedVar:Variable)
PartialFlowCallDataLoadToExternalCall(sourceStmt, dataInputSrcVar, callStmt, sigHash, taintedVar) :-
  CALLDATALOAD(sourceStmt, _, dataInputSrcVar),
  DataFlows(dataInputSrcVar, taintedVar),
  CallToSignatureHex(callStmt, sigHash),
  StatementUsesMemory_ActualMemoryArg(callStmt, _, _, taintedVar),
  ExternalCallIsNotOracleOrSink(callStmt, sigHash).
.output PartialFlowCallDataLoadToExternalCall

/**
 * Partial flow from CALLDATALOAD to Sink
**/
.decl PartialFlowCallDataLoadToSink(sourceStmt:Statement, dataInputSrcVar:Variable, sinkStmt:Statement, amount:Variable)
PartialFlowCallDataLoadToSink(sourceStmt, dataInputSrcVar, sinkStmt, amount) :-
  CALLDATALOAD(sourceStmt, _, dataInputSrcVar),
  DataFlows(dataInputSrcVar, amount),
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output PartialFlowCallDataLoadToSink

/**
 * Partial flow from ExternalCall to Sink
**/
.decl PartialFlowExternalCallToSink(callStmt:Statement, sigHash:symbol, sinkStmt:Statement, amount:Variable)
PartialFlowExternalCallToSink(callStmt, sigHash, sinkStmt, amount) :-
  CallToSignatureHex(callStmt, sigHash),
  ExternalCallIsNotSink(callStmt, sigHash),
  ExternalCall_ActualReturn(callStmt, possiblyTaintedVar, _),
  DataFlows(possiblyTaintedVar, amount),
  (ERC20TransferCall(sinkStmt, _, amount);ERC20TransferFromCall(sinkStmt, _, _, amount)).
.output PartialFlowExternalCallToSink